<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
</head>

<body>
  <canvas id="world"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.js"></script>
  <script src="https://cdn.rawgit.com/phi-jp/phina.js/v0.1.1/build/phina.js"></script>
  <script src="glfilter/glfilterlayer.js"></script>
  <script src="glfilter/screen.js"></script>
  <script src="glfilter/shadernode.js"></script>
  <script src="glfilter/scenerendernode.js"></script>
  <script src="glfilter/destinationnode.js"></script>
  <script src="glfilter/effectnode/sepianode.js"></script>
  <script src="glfilter/effectnode/monotonenode.js"></script>
  <script src="glfilter/effectnode/reversenode.js"></script>
  <script src="glfilter/effectnode/zoomblurnode.js"></script>
  <script src="glfilter/effectnode/brightnesscontrastnode.js"></script>
  <script>
  var SCREEN_WIDTH = 640;
  var SCREEN_HEIGHT = 480;

  phina.main(function() {
    var app = phina.display.CanvasApp({
      query: "#world",
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });
    app.run();

    phina.asset.AssetLoader()
      .load({
        image: {
          phina: "phina.png",
        }
      })
      .then(function() {
        app.replaceScene(MainScene());
      });
  });

  phina.define("MainScene", {
    superClass: "phina.display.CanvasScene",
    init: function() {
      this.superInit({
        width: SCREEN_WIDTH,
        height: SCREEN_HEIGHT,
      });

      var layer = phina.glfilter.GLFilterLayer({
        width: SCREEN_WIDTH,
        height: SCREEN_HEIGHT,
      }).addChildTo(this);

      phina.display.Sprite("phina")
        .setPosition(SCREEN_WIDTH * 0.5, SCREEN_HEIGHT * 0.5)
        .setScale(SCREEN_WIDTH / 1700 * 0.5)
        .on("enterframe", function(e) {
          var f = e.app.ticker.frame;
          this.setRotation(Math.sin(f * 0.1) * 30);
        })
        .addChildTo(layer);

      var effectSelector = EffectSelector(layer);

      var gui = new dat.GUI();
      gui.add(effectSelector, "effect", [
          "none",
          "sepia",
          "monotone",
          "reverse",
          "zoomBlur",
          "sepia + zoomBlur",
          "brightness contrast",
        ])
        .name("effect")
        .onChange(function(value) {
          effectSelector.effect = value;
        });
    }
  });

  phina.define("EffectSelector", {
    currentLayer: null,
    init: function(layer) {
      this.layer = layer;
      this.effect = "none";
    },
    setEffect: function(effectType) {
      this._effect = effectType;

      var layer = this.layer;

      layer.clear("enterframe");

      var newNode = null;
      var newNode2 = null;
      switch (effectType) {
        case "sepia":
          newNode = phina.glfilter.SepiaNode(layer.gl);
          layer.setPasses(newNode);
          break;
        case "monotone":
          newNode = phina.glfilter.MonotoneNode(layer.gl);
          layer.setPasses(newNode);
          break;
        case "reverse":
          newNode = phina.glfilter.ReverseNode(layer.gl);
          layer.setPasses(newNode);
          break;
        case "zoomBlur":
          newNode = phina.glfilter.ZoomBlurNode(layer.gl);
          layer.setPasses(newNode);

          layer.on("enterframe", function(e) {
            var p = e.app.pointer;
            newNode.x = p.x;
            newNode.y = p.y;
          });
          break;
        case "sepia + zoomBlur":
          newNode = phina.glfilter.SepiaNode(layer.gl);
          newNode2 = phina.glfilter.ZoomBlurNode(layer.gl);
          layer.setPasses(newNode, newNode2);

          layer.on("enterframe", function(e) {
            var p = e.app.pointer;
            newNode2.x = p.x;
            newNode2.y = p.y;
          });
          break;
        case "brightness contrast":
          newNode = phina.glfilter.BrightnessContrastNode(layer.gl);
          layer.setPasses(newNode);

          layer.on("enterframe", function(e) {
            var p = e.app.pointer;
            newNode.brightness = p.x / SCREEN_WIDTH;
            newNode.contrast = p.y / SCREEN_HEIGHT;
          });
          break;
      }

      if (!newNode) {
        layer.headNode.connectTo(layer.destNode);
      }
    },
    _accessor: {
      "effect": {
        get: function() {
          return this._effect
        },
        set: function(v) {
          this.setEffect(v)
        }
      }
    }
  });
  </script>
</body>

</html>
