{"version":3,"sources":["GLFilterLayer.js","GLFilterNode.js","effectnode/monotonenode.js","effectnode/reversenode.js","effectnode/sepianode.js","effectnode/zoomblurnode.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"phina.glfilter.js","sourcesContent":["phina.namespace(function() {\n\n  phina.define(\"phina.glfilter.GLFilterLayer\", {\n    superClass: \"phina.display.Layer\",\n\n    _filterNodes: null,\n\n    init: function(options) {\n      this.superInit(options);\n\n      this._filterNodes = [];\n\n      var width = options.width;\n      var height = options.height;\n\n      // 2D\n      this.canvas = phina.graphics.Canvas();\n      this.canvas.width = width;\n      this.canvas.height = height;\n      this.aspectRate = width / height;\n      this.renderer = phina.display.CanvasRenderer(this.canvas);\n      this.domElement = this.canvas.domElement;\n\n      // 3D\n      this.sizeInfo = phigl.ImageUtil.calcSizePowOf2(width, height);\n      this.domElementGL = document.createElement(\"canvas\");\n\n      var gl = this.gl = this.domElementGL.getContext(\"webgl\");\n\n      this.domElementGL.width = this.sizeInfo.width;\n      this.domElementGL.height = this.sizeInfo.height;\n      gl.viewport(0, 0, this.sizeInfo.width, this.sizeInfo.height);\n\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n\n      this.resizedCanvas = phina.graphics.Canvas();\n      this.resizedCanvas.setSize(this.sizeInfo.width, this.sizeInfo.height);\n      this.screenTexture = phigl.Texture(gl);\n\n      this.framebuffer0 = phigl.Framebuffer(gl, this.sizeInfo.width, this.sizeInfo.height);\n      this.framebuffer1 = phigl.Framebuffer(gl, this.sizeInfo.width, this.sizeInfo.height);\n\n      this.startNode = phina.glfilter.StartNode();\n      this.startNode.gl = this.gl;\n      this.endNode = phina.glfilter.EndNode();\n      this.endNode.gl = this.gl;\n    },\n\n    addFilterNode: function(filterNode) {\n      filterNode.gl = this.gl;\n      this._filterNodes.push(filterNode);\n      return this;\n    },\n\n    render: function() {\n      var sizeInfo = this.sizeInfo;\n      this.resizedCanvas.clear();\n      this.resizedCanvas.context.drawImage(this.domElement,\n        // src\n        0, 0, this.width, this.height,\n        // dst\n        sizeInfo.srcX, sizeInfo.srcY, sizeInfo.srcWidth, sizeInfo.srcHeight\n      );\n      this.screenTexture.setImage(this.resizedCanvas);\n\n      this.startNode.render(this.screenTexture, this.framebuffer1);\n\n      var src = this.framebuffer1;\n      var dst = this.framebuffer0;\n      this._filterNodes\n        .filter(function(filterNode) {\n          return filterNode.enabled;\n        })\n        .forEach(function(filterNode) {\n          filterNode.render(src.texture, dst);\n\n          var temp = src;\n          src = dst;\n          dst = temp;\n        });\n\n      this.endNode.render(src.texture);\n    },\n\n    draw: function(canvas) {\n      // 2D\n      var temp = this._worldMatrix;\n      this._worldMatrix = null;\n      this.renderer.render(this);\n      this._worldMatrix = temp;\n\n      // 3D\n      this.render();\n\n      var domElementGL = this.domElementGL;\n      var sizeInfo = this.sizeInfo;\n      canvas.context.drawImage(domElementGL,\n        // src\n        sizeInfo.srcX, sizeInfo.srcY, sizeInfo.srcWidth, sizeInfo.srcHeight,\n        // dst\n        -this.width * this.originX, -this.height * this.originY, this.width, this.height\n      );\n    },\n\n  });\n\n});","phina.namespace(function() {\n\n  // var projectionMatrix = mat4.create();\n  // var viewMatrix = mat4.create();\n  // var modelMatrix = mat4.create();\n  // var mvpMatrix = mat4.create();\n  // mat4.ortho(projectionMatrix, -0.5, 0.5, -0.5, 0.5, 0.9, 1.1);\n  // mat4.lookAt(viewMatrix, [0, 0, 1], [0, 0, 0], [0, 1, 0]);\n  // mat4.mul(mvpMatrix, projectionMatrix, viewMatrix);\n  // mat4.mul(mvpMatrix, mvpMatrix, modelMatrix);\n  var mvpMatrix = new Float32Array([2, 0, 0, 0, 0, 2, 0, 0, 0, 0, -10, 0, 0, 0, 0, 1]);\n\n  phina.define(\"phina.glfilter.GLFilterNode\", {\n\n    gl: null,\n    enabled: true,\n    uniformValues: null,\n\n    init: function() {\n      this.uniformValues = {};\n      this.$watch(\"gl\", function(value, oldValue) {\n        if (!oldValue && value) {\n          this.setup(value);\n        }\n      });\n    },\n\n    setup: function(gl) {\n      this.screen = phigl.Drawable(gl)\n        .setProgram(this._createProgram(gl))\n        .setGeometry(phigl.PlaneXY({\n          width: 1,\n          height: 1,\n          normalsEnabled: false,\n        }))\n        .declareUniforms([].concat(this.getVertexShaderUniforms(), this.getFragmentShaderUniforms()));\n      this.screen.uniforms[\"mvpMatrix\"].setValue(mvpMatrix);\n    },\n\n    render: function(src, dst) {\n      var gl = this.gl;\n\n      dst.bind();\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      this.screen.uniforms[\"texture\"].setValue(0).setTexture(src);\n      this.uniformValues\n        .forIn(function(key, value) {\n          if (key === \"texture\") return;\n          this.screen.uniforms[key].setValue(value);\n        }.bind(this));\n      this.screen.draw();\n\n      gl.flush();\n    },\n\n    _createProgram: function(gl) {\n      var srcV = this.getVertexShaderSource();\n      var srcF = this.getFragmentShaderSource();\n\n      return phigl.Program(gl)\n        .attach(phigl.VertexShader().setSource(srcV))\n        .attach(phigl.FragmentShader().setSource(srcF))\n        .link();\n    },\n\n    getVertexShaderSource: function() {\n      return [\n        \"attribute vec3 position;\",\n        \"attribute vec2 uv;\",\n\n        \"uniform mat4 mvpMatrix;\",\n\n        \"varying vec2 vUv;\",\n\n        \"void main(void) {\",\n        \"  vUv = uv;\",\n        \"  gl_Position = mvpMatrix * vec4(position, 1.0);\",\n        \"}\",\n      ].join(\"\\n\");\n    },\n    getVertexShaderUniforms: function() {\n      return [\"mvpMatrix\"];\n    },\n\n    getFragmentShaderSource: function() {\n      return [\n        \"precision mediump float;\",\n\n        \"uniform sampler2D texture;\",\n\n        \"varying vec2 vUv;\",\n\n        \"void main(void) {\",\n        \"  vec4 col = texture2D(texture, vUv);\",\n        \"  if (col.a == 0.0) discard;\",\n        \"  gl_FragColor = col;\",\n        \"}\",\n      ].join(\"\\n\");\n    },\n    getFragmentShaderUniforms: function() {\n      return [\"texture\"];\n    },\n\n  });\n\n  phina.define(\"phina.glfilter.StartNode\", {\n    superClass: \"phina.glfilter.GLFilterNode\",\n\n    init: function() {\n      this.superInit();\n    },\n\n    getFragmentShaderSource: function() {\n      return [\n        \"precision mediump float;\",\n\n        \"uniform sampler2D texture;\",\n\n        \"varying vec2 vUv;\",\n\n        \"void main(void) {\",\n        \"  vec4 col = texture2D(texture, vec2(vUv.x, 1.0 - vUv.y));\",\n        \"  if (col.a == 0.0) discard;\",\n        \"  gl_FragColor = col;\",\n        \"}\",\n      ].join(\"\\n\");\n    },\n  });\n\n  phina.define(\"phina.glfilter.EndNode\", {\n    superClass: \"phina.glfilter.GLFilterNode\",\n\n    init: function() {\n      this.superInit();\n    },\n\n    render: function(src/*, dst*/) {\n      var gl = this.gl;\n\n      phigl.Framebuffer.unbind(gl);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      this.screen.uniforms[\"texture\"].setValue(0).setTexture(src);\n      this.screen.draw();\n\n      gl.flush();\n    },\n  });\n\n});","phina.namespace(function() {\n\n  phina.define(\"phina.glfilter.MonotoneNode\", {\n    superClass: \"phina.glfilter.GLFilterNode\",\n\n    init: function() {\n      this.superInit();\n    },\n\n    getFragmentShaderSource: function() {\n      return [\n        \"precision mediump float;\",\n\n        \"uniform sampler2D texture;\",\n\n        \"varying vec2 vUv;\",\n\n        \"void main(void) {\",\n        \"  vec4 col = texture2D(texture, vUv);\",\n        \"  if (col.a == 0.0) discard;\",\n        \"  float c = col.r + col.g + col.b;\",\n        \"  gl_FragColor = vec4(vec3(c / 3.0), col.a);\",\n        \"}\",\n      ].join(\"\\n\");\n    },\n  });\n\n});","phina.namespace(function() {\n\n  phina.define(\"phina.glfilter.ReverseNode\", {\n    superClass: \"phina.glfilter.GLFilterNode\",\n\n    init: function() {\n      this.superInit();\n    },\n\n    getFragmentShaderSource: function() {\n      return [\n        \"precision mediump float;\",\n\n        \"uniform sampler2D texture;\",\n\n        \"varying vec2 vUv;\",\n\n        \"void main(void) {\",\n        \"  vec4 col = texture2D(texture, vUv);\",\n        \"  if (col.a == 0.0) discard;\",\n        \"  gl_FragColor = vec4(1.0 - col.rgb, col.a);\",\n        \"}\",\n      ].join(\"\\n\");\n    },\n  });\n\n});","phina.namespace(function() {\n\n  phina.define(\"phina.glfilter.SepiaNode\", {\n    superClass: \"phina.glfilter.GLFilterNode\",\n\n    init: function() {\n      this.superInit();\n    },\n\n    getFragmentShaderSource: function() {\n      return [\n        \"precision mediump float;\",\n\n        \"uniform sampler2D texture;\",\n\n        \"varying vec2 vUv;\",\n\n        \"void main(void) {\",\n        \"  vec4 tex = texture2D(texture, vUv);\",\n        \"  vec3 c = vec3((tex.r + tex.g + tex.b) / 3.0);\",\n        \"  gl_FragColor = vec4(c.r * 1.2, c.g * 1.05, c.b * 0.9, tex.a);\",\n        \"}\",\n      ].join(\"\\n\");\n    },\n  });\n\n});\n","phina.namespace(function() {\n\n  phina.define(\"phina.glfilter.ZoomBlurNode\", {\n    superClass: \"phina.glfilter.GLFilterNode\",\n\n    init: function() {\n      this.superInit();\n    },\n\n    getFragmentShaderSource: function() {\n      return [\n        \"precision mediump float;\",\n\n        \"uniform sampler2D texture;\",\n        \"uniform float x;\",\n        \"uniform float y;\",\n\n        \"varying vec2 vUv;\",\n\n        \"const float nFrag = 1.0 / 30.0;\",\n        \"const float strength = 8.0;\",\n\n        \"float rnd(vec3 scale, float seed){\",\n        \"    return fract(sin(dot(gl_FragCoord.stp + seed, scale)) * 43758.5453 + seed);\",\n        \"}\",\n\n        \"void main(void){\",\n        \"    vec2  center = vec2(x, 1.0 - y);\",\n        \"    vec4  destColor = vec4(0.0);\",\n        \"    float random = rnd(vec3(12.9898, 78.233, 151.7182), 0.0);\",\n        \"    vec2  fcc = vUv - center;\",\n        \"    float totalWeight = 0.0;\",\n        \"\",\n        \"    for(float i = 0.0; i <= 30.0; i++){\",\n        \"        float percent = (i + random) * nFrag;\",\n        \"        float weight = percent - percent * percent;\",\n        \"        vec2  t = vUv - fcc * percent * strength * nFrag;\",\n        \"        vec4 col = texture2D(texture, t);\",\n        \"        destColor += col * weight;\",\n        \"        totalWeight += weight;\",\n        \"    }\",\n        \"    gl_FragColor = vec4(destColor / totalWeight);\",\n        \"}\",\n      ].join(\"\\n\");\n    },\n    getFragmentShaderUniforms: function() {\n      return [\"texture\", \"x\", \"y\"];\n    },\n\n  });\n\n});\n"]}